/*
 * Blowfish implementation just to understand what a strong crypto looks like, get a refresher on C
 * P and S are arbitrary, with random primes they'll provide more entropy to crypto
 */
#include <stdio.h>

#define N 16
typedef struct {
	unsigned long P[N + 2];
	unsigned long  S[4][256];
} BlowfishCtx;

// Arbitrary
static const unsigned long ORIG_P[N + 2] = {
        0, 1, 2, 3,
        4, 5, 6, 7,
        8, 9, 10, 11,
        12, 13, 14, 15,
        16, 17
};

static const unsigned long ORIG_S[4][256] = {
		{86, 25, 59, 90, 37, 43, 22, 65, 11, 0, 82, 2, 67, 89, 36, 22, 33, 7, 10, 11, 1, 47, 18, 13, 24, 55, 93, 13, 36, 18, 55, 24, 30, 92, 45, 27, 71, 39, 83, 57, 95, 64, 41, 58, 38, 56, 11, 72, 81, 57, 69, 45, 38, 36, 29, 75, 74, 21, 4, 92, 79, 18, 57, 59, 2, 41, 44, 66, 70, 83, 46, 91, 5, 43, 95, 15, 93, 60, 86, 16, 0, 19, 62, 16, 81, 31, 58, 54, 2, 37, 90, 14, 7, 8, 16, 54, 29, 85, 5, 63, 64, 25, 28, 61, 7, 6, 26, 61, 83, 79, 74, 64, 75, 24, 39, 12, 76, 81, 75, 0, 25, 35, 89, 46, 43, 91, 11, 62, 91, 38, 15, 64, 27, 53, 26, 36, 27, 96, 3, 82, 13, 60, 10, 18, 51, 87, 73, 97, 82, 2, 12, 70, 58, 68, 93, 14, 46, 32, 89, 13, 23, 25, 60, 3, 90, 26, 69, 39, 4, 53, 11, 11, 19, 0, 95, 6, 79, 63, 28, 73, 7, 9, 19, 43, 1, 34, 11, 21, 94, 94, 44, 98, 74, 90, 59, 36, 59, 2, 33, 10, 80, 30, 29, 28, 17, 50, 67, 31, 74, 14, 31, 88, 76, 49, 1, 42, 97, 6, 10, 31, 62, 4, 42, 75, 13, 34, 36, 50, 92, 4, 68, 99, 81, 68, 84, 42, 71, 58, 45, 56, 16, 31, 97, 60, 81, 19, 97, 15, 0, 52, 69, 68, 39, 6, 43, 56},
		{0, 46, 66, 98, 90, 95, 92, 58, 45, 74, 79, 32, 44, 50, 112, 103, 73, 99, 81, 61, 81, 117, 62, 55, 32, 95, 26, 111, 82, 67, 108, 36, 115, 95, 81, 40, 56, 98, 101, 61, 128, 136, 78, 53, 141, 117, 128, 63, 129, 59, 121, 147, 127, 86, 110, 90, 65, 68, 147, 102, 94, 156, 81, 78, 147, 98, 141, 109, 74, 128, 166, 152, 113, 105, 114, 163, 118, 123, 88, 118, 139, 137, 148, 107, 178, 169, 140, 89, 184, 97, 92, 156, 160, 117, 94, 104, 190, 100, 114, 114, 101, 124, 180, 148, 200, 126, 181, 127, 179, 131, 199, 151, 179, 148, 151, 208, 208, 202, 157, 187, 212, 125, 136, 217, 132, 127, 162, 129, 194, 225, 209, 166, 157, 157, 162, 232, 173, 188, 186, 188, 179, 161, 223, 211, 242, 172, 219, 173, 204, 216, 179, 208, 195, 236, 247, 182, 231, 194, 251, 161, 173, 195, 180, 206, 200, 215, 206, 217, 255, 247, 225, 246, 267, 240, 217, 229, 202, 216, 249, 264, 270, 212, 275, 257, 204, 280, 207, 249, 190, 252, 245, 261, 195, 235, 201, 263, 212, 289, 287, 276, 222, 247, 290, 285, 299, 244, 293, 241, 283, 277, 253, 222, 255, 254, 296, 222, 309, 308, 281, 227, 297, 281, 262, 228, 288, 315, 275, 292, 244, 291, 273, 326, 298, 296, 276, 284, 270, 309, 248, 251, 282, 276, 332, 318, 273, 336, 246, 336, 259, 296, 314, 267, 287, 304, 267, 264},
		{78, 29, 72, 86, 11, 22, 60, 34, 40, 92, 86, 30, 81, 96, 87, 59, 47, 61, 105, 110, 116, 133, 97, 112, 104, 51, 68, 126, 92, 101, 115, 125, 161, 117, 89, 163, 145, 74, 90, 139, 89, 167, 180, 176, 165, 165, 150, 163, 142, 104, 124, 125, 158, 119, 149, 143, 116, 189, 151, 126, 219, 159, 142, 208, 164, 192, 138, 226, 201, 179, 209, 145, 149, 232, 194, 158, 229, 195, 222, 230, 193, 194, 182, 196, 212, 240, 202, 241, 226, 195, 187, 260, 209, 265, 233, 282, 286, 257, 277, 220, 243, 213, 226, 227, 230, 241, 291, 257, 239, 285, 224, 308, 265, 264, 249, 269, 319, 290, 307, 273, 296, 263, 303, 300, 319, 337, 326, 330, 306, 297, 341, 327, 336, 304, 350, 343, 359, 283, 300, 334, 334, 317, 298, 309, 322, 325, 390, 339, 360, 300, 393, 302, 357, 377, 396, 388, 326, 325, 316, 366, 410, 403, 378, 327, 395, 377, 334, 377, 367, 410, 432, 346, 433, 352, 428, 407, 410, 416, 423, 375, 422, 372, 401, 458, 432, 430, 383, 416, 438, 455, 411, 474, 390, 479, 466, 477, 432, 479, 463, 450, 406, 460, 427, 491, 417, 428, 495, 435, 440, 486, 460, 481, 497, 427, 511, 517, 523, 470, 524, 465, 508, 500, 542, 473, 472, 488, 466, 485, 464, 463, 468, 477, 466, 538, 504, 558, 523, 523, 501, 534, 522, 516, 525, 574, 561, 520, 494, 541, 506, 521, 553, 562, 580, 538, 566, 556},
		{13, 78, 40, 87, 26, 46, 88, 98, 115, 90, 46, 104, 121, 120, 119, 92, 108, 83, 67, 117, 98, 90, 68, 137, 116, 142, 98, 117, 163, 156, 138, 171, 109, 132, 181, 191, 205, 191, 205, 204, 197, 169, 220, 167, 231, 152, 141, 159, 197, 177, 239, 250, 202, 159, 172, 256, 202, 227, 177, 234, 188, 280, 226, 199, 237, 261, 297, 228, 282, 270, 256, 270, 282, 256, 296, 276, 295, 247, 240, 251, 253, 255, 310, 322, 252, 317, 290, 281, 349, 334, 276, 309, 300, 284, 327, 339, 339, 347, 320, 359, 302, 351, 306, 361, 355, 339, 362, 362, 351, 401, 377, 373, 433, 411, 367, 349, 396, 375, 419, 456, 388, 453, 393, 389, 428, 398, 386, 443, 385, 387, 407, 445, 481, 498, 422, 471, 485, 462, 454, 470, 454, 438, 517, 514, 497, 442, 518, 521, 475, 457, 528, 455, 491, 532, 495, 538, 504, 510, 537, 559, 517, 511, 526, 533, 516, 569, 505, 539, 523, 554, 601, 598, 555, 561, 547, 531, 613, 611, 588, 554, 549, 580, 588, 628, 614, 603, 610, 644, 633, 657, 650, 647, 666, 602, 612, 670, 600, 599, 670, 642, 644, 653, 627, 676, 640, 705, 715, 624, 650, 724, 704, 685, 665, 659, 684, 662, 695, 727, 684, 683, 676, 754, 728, 724, 694, 741, 759, 692, 700, 730, 752, 730, 769, 791, 730, 737, 798, 747, 748, 758, 733, 765, 751, 772, 804, 776, 759, 796, 771, 819, 759, 810, 763, 801, 803, 781}
};


unsigned long  F(BlowfishCtx *ctx, unsigned long  x) {
	// Divide message into 4 bytes
	unsigned short a, b, c, d;
	unsigned long  y;

	a = (unsigned short) x & 0x00FF;
	x >>= 8;

	b = (unsigned short) x & 0x00FF;
	x >>= 8;

	c = (unsigned short) x & 0x00FF;
	x >>= 8;

	d = (unsigned short) x & 0x00FF;
	x >>= 8;

	y = ctx->S[0][a] + ctx->S[1][b];
	y = y ^ ctx->S[2][c];
	y = y + ctx->S[3][d];
	return y;
}

void swap(unsigned long  *x, unsigned long  *y) {
	unsigned long  tmp = *x;
	*x = *y;
	*y = tmp;
}

void bfish_encrypt(BlowfishCtx *ctx, unsigned long *datal, unsigned long *datar) {
	unsigned long xl, xr;
	int i;

	xr = *datar;
	xl = *datal;

	for (i = 0; i < N; i++) {
		xl = xl ^ ctx->P[i];
		xr = F(ctx, xl) ^ xr;
		swap(&xr, &xl);
	}
	swap(&xr, &xl);
	xr = xr ^ ctx->P[N];
	xl = xl ^ ctx->P[N + 1];

	*datal = xl;
	*datar = xr;
}

void bfish_decrypt(BlowfishCtx *ctx, unsigned long  *datal, unsigned long  *datar) {
	unsigned long xl, xr;
	int i;

	xr = *datar;
	xl = *datal;

	for (i = N + 1; i > 1; --i) {
		xl = xl ^ ctx->P[i];
		xr = F(ctx, xl) ^ xr;
		swap(&xr, &xl);
	}
	swap(&xr, &xl);
	xr = xr ^ ctx->P[1];
	xl = xl ^ ctx->P[0];

	*datal = xl;
	*datar = xr;
}

// at most 448 bits into several subkey arrays, totaling 4168bytes
void bfish_init(BlowfishCtx *ctx, unsigned char *key, int key_len) {
	unsigned long data;
	unsigned long datal;
	unsigned long datar;
	int i;
	int j;

	// init P-array with PI digits in hex 3.243F6 A8885 A308D 31319 8A2E0 37073 44A40 93822 299F3 1D008 2EFA9 8EC4E 6C894 52821 E638D 01377 BE546 6CF34 E90C6 CC0AC
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 256; j++) {
			ctx->S[i][j] = ORIG_S[i][j];
		}
	}

	j = 0;
	for (i = 0; i < N + 2; i++) {
		data = 0x00000000;

		for (int k = 0; k < 4; ++k) {
			data = (data << 8) | key[j];
			j = (j + 1) % key_len;
		}
		ctx->P[i] = ORIG_P[i] ^ data;
	}

	datal = 0x00000000;
	datar = 0x00000000;
	for (i = 0; i < N + 2; i += 2) {
		bfish_encrypt(ctx, &datal, &datar);
		ctx->P[i] = datal;
		ctx->P[i + 1] = datar;
	}

	for (i = 0; i < 4; i++) {
		for (j = 0; j < 256; j += 2) {
			bfish_encrypt(ctx, &datal, &datar);
			ctx->S[i][j] = datal;
			ctx->S[i][j + 1] = datar;
		}
	}
}

int main(void) {
	   unsigned long  L = 1, R = 2;

	   BlowfishCtx ctx;
	   bfish_init(&ctx, (unsigned char*)"heyyah!", 7);
	   bfish_encrypt(&ctx, &L, &R);
	   bfish_decrypt(&ctx, &L, &R);
	   if (L != 1 || R != 2) {
		   puts("pau na decrypt");
		   return -1;
	   }

	   return 0;
}
